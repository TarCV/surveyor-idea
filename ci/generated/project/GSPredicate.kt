/*
 Copyright (C) 2024 TarCV

 This file is part of UI Surveyor.
 UI Surveyor is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 (at your option) any later version.

 This program is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with this program.  If not, see <https://www.gnu.org/licenses/>.

 This file is based on parts of GNUstep that are covered under the following terms
 (Copies of referenced files can be found in ipredicate/licenses/gnustepbase subdirectory in this
 repository):

 * GSVersionMacros.h - macros for managing API versioning and visibility
   Copyright (C) 2006-2014 Free Software Foundation, Inc.

   Written by: Richard Frith-Macdonald <rfm@gnu.org>
   Date: Oct, October 2006

   This file is part of GNUstep.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.

 * GNUstep.h - macros to make easier to port gnustep apps to macos-x
   Copyright (C) 2001 Free Software Foundation, Inc.

   Written by: Nicola Pero <n.pero@mi.flashnet.it>
   Date: March, October 2001
   
   This file is part of GNUstep.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.

 * Interface to ObjC runtime for GNUStep
   Copyright (C) 1995, 1997, 2000 Free Software Foundation, Inc.

   Written by:  Andrew Kachites McCallum <mccallum@gnu.ai.mit.edu>
   Date: 1995

   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Interface for NSException for GNUStep
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.

   Written by:  Adam Fedor <fedor@boulder.colorado.edu>
   Date: 1995
   
   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Interface for NSPredicate for GNUStep
   Copyright (C) 2005 Free Software Foundation, Inc.

   Written by:  Dr. H. Nikolaus Schaller
   Created: 2005
   
   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Definitions for NSScanner class
   Copyright (C) 1996,1999 Free Software Foundation, Inc.

   Author:  Eric Norum <eric@skatter.usask.ca>
   Created: 1996
   
   This file is part of the GNUstep Objective-C Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Implemenation of NSScanner class
   Copyright (C) 1996,1999 Free Software Foundation, Inc.

   Author:  Eric Norum <eric@skatter.usask.ca>
   Date: 1996
   Rewrite/optimisation by:  Richard Frith-Macdonald <rfm@gnu.org>
   Date: 1998

   This file is part of the GNUstep Objective-C Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Interface for NSComparisonPredicate for GNUStep
   Copyright (C) 2005 Free Software Foundation, Inc.

   Written by:  Dr. H. Nikolaus Schaller
   Created: 2005
   
   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Interface for NSCompoundPredicate for GNUStep
   Copyright (C) 2005 Free Software Foundation, Inc.

   Written by:  Dr. H. Nikolaus Schaller
   Created: 2005
   
   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
   
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.

 * Interface for NSPredicate for GNUStep
   Copyright (C) 2005 Free Software Foundation, Inc.

   Written by:  Dr. H. Nikolaus Schaller
   Created: 2005
   Modifications: Fred Kiefer <FredKiefer@gmx.de>
   Date: May 2007
   Modifications: Richard Frith-Macdoanld <rfm@gnu.org>
   Date: June 2007
   
   This file is part of the GNUstep Base Library.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public
   License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.
  
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.
   
   You should have received a copy of the GNU General Public
   License along with this library; if not, write to the Free
   Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110 USA.
*/
package com.github.tarcv.testingteam.surveyor.ipredicate
import com.github.tarcv.testingteam.surveyor.ipredicate.NSString.Companion.toNSString
import java.lang.IllegalArgumentException
import java.lang.IllegalStateException
import java.lang.Math.pow

val NSObject._cVarArgEncoding: List<Int>
    get() {
        return listOf(1, 1)
    }

internal inline fun isEqual(lhs: AnyObject?, rhs: AnyObject?): Boolean = lhs == rhs

internal inline fun notIsEqual(lhs: AnyObject?, rhs: AnyObject?): Boolean = lhs != rhs

internal enum class NSComparisonResult(val rawValue: Int) {
    NS_ORDERED_ASCENDING(rawValue = 0),
    NS_ORDERED_SAME(rawValue = 1),
    NS_ORDERED_DESCENDING(rawValue = 2);

    companion object {
        operator fun invoke(rawValue: Int): NSComparisonResult? = values().firstOrNull { it.rawValue == rawValue }
    }
}

// TODO: Redeclaration? typealias NSExceptionName = NSString!
// TODO: Redeclaration? var NSCharacterConversionException:NSString
// TODO: Redeclaration? var NSDestinationInvalidException:NSString
// TODO: Redeclaration? var NSGenericException:NSString
// TODO: Redeclaration? var NSInternalInconsistencyException:NSString
// TODO: Redeclaration? var NSInvalidArgumentException:NSString
// TODO: Redeclaration? var NSInvalidReceivePortException:NSString
// TODO: Redeclaration? var NSInvalidSendPortException:NSString
// TODO: Redeclaration? var NSMallocException:NSString
// TODO: Redeclaration? var NSObjectInaccessibleException:NSString
// TODO: Redeclaration? var NSObjectNotAvailableException:NSString
// TODO: Redeclaration? var NSOldStyleException:NSString
// TODO: Redeclaration? var NSParseErrorException:NSString
// TODO: Redeclaration? var NSPortReceiveException:NSString
// TODO: Redeclaration? var NSPortSendException:NSString
// TODO: Redeclaration? var NSPortTimeoutException:NSString
// TODO: Redeclaration? var NSRangeException:NSString
// TODO: Redeclaration? var NSAssertionHandlerKey:NSString
internal val defaultSkipSet: NSCharacterSet = NSCharacterSet.whitespacesAndNewlines as NSCharacterSet
internal val powersOf10: List<Double> = listOf(10.0, 100.0, 10000.0, 100000000.0, 1e+16, 1e+32, 1e+64, 1e+128, 1e+256)

internal open class NSScanner {
    companion object {
        fun scannerWithString(aString: NSString): NSScanner {
            return NSScanner(aString = aString)!!
        }

        fun localizedScannerWithString(aString: NSString): NSScanner {
            val scanner: NSScanner = this.scannerWithString(aString = aString)
            if (scanner != null) {
                val loc: Map<NSString, Any> = UserDefaults.standard.dictionaryRepresentation()
                scanner.setLocale(loc as Map<NSString, Any>)
            }
            return scanner
        }

        fun _scanDouble(value: InOut<Double>, str: NSString): Boolean {
            //      let myLock:gs_mutex_t = GS_MUTEX_INIT_STATIC
            var _doubleScanner: NSScanner? = null
            var ok: Boolean = false

            //      GS_MUTEX_LOCK(myLock)
            val doubleScanner: NSScanner = _doubleScanner ?: NSScanner(aString = "".toNSString())!!

            _doubleScanner = doubleScanner

            doubleScanner._setString(aString = str)

            ok = doubleScanner.scanDouble(value)

            doubleScanner._setString(aString = "".toNSString())

            //      GS_MUTEX_UNLOCK(myLock)
            return ok
        }
    }

    constructor(aString: String?): this(aString?.toNSString())

    constructor(aString: NSString?) {
        val aString_: NSString = aString ?: "".toNSString()
        if (true) {
            if (aString == null) {
                NSLog("Scanner initialised with nil string".toNSString())
            }
            if ((aString_ is NSString) == false) {
                throw IllegalArgumentException("Scanner initialised with something not a string")
            }
            else {
                this._setString(aString = aString_)
                this._charactersToBeSkipped = defaultSkipSet
                _decimal = ".".utf16.first!!
            }
        }
    }

    private lateinit var _string: NSString
    private var _charactersToBeSkipped: NSCharacterSet? = null
    private var _locale: Map<NSString, Any>? = null
    private var _scanLocation: Int = 0
    private var _decimal: UShort = 0.toUShort()
    private var _caseSensitive: Boolean = false
    private var _isUnicode: Boolean = false

    open fun _setString(aString: String?) = _setString(aString?.toNSString())
    open fun _setString(aString: NSString?) {
        val aString_: NSString = aString ?: "".toNSString()

        _scanLocation = 0
        _isUnicode = false

            var c: (NSString) = (aString_)

            //_string = nil
            if ((c != null) == true) {
                _string = (aString_)
            }
            else {
                _string = aString_.toNSString()
            }

            c = _string

            if ((c != null) == true) {
                _isUnicode = true
            }
    }

    open fun isAtEnd(): Boolean {
        var save__scanLocation: Int
        var ret: Boolean

        if (_scanLocation >= _string.utf16.count) {
            return true
        }

        save__scanLocation = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        ret = !(if ((_scanLocation >= _string.utf16.count)) { false } else { true })
        _scanLocation = save__scanLocation

        return ret
    }

    open fun _scanInt(value: InOut<Int>): Boolean {
        var num: UInt = 0u
        val limit: UInt = 0xffffffffu / 10u
        var negative: Boolean = false
        var overflow: Boolean = false
        var got_digits: Boolean = false

        if (_scanLocation < _string.utf16.count) {
            when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                "+".utf16.first!! -> _scanLocation += 1
                "-".utf16.first!! -> {
                    negative = true
                    _scanLocation += 1
                }
                else -> {
                }
            }
        }

        while (_scanLocation < _string.utf16.count) {
            val digit: UShort = _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]

            if ((digit < "0".utf16.first!!) || (digit > "9".utf16.first!!)) {
                break
            }

            if (!overflow) {
                if (num >= limit) {
                    overflow = true
                }
                else {
                    num = num * UInt(10u) + UInt(digit - "0".utf16.first!!)
                }
            }

            _scanLocation += 1

            got_digits = true
        }

        if (!got_digits) {
            return false
        }

        if ((value != null)) {
            if (overflow || (num > (if (negative) { (UInt.min) } else { (UInt.max) }))) {
                value `=` Int(if (negative) { UInt.min } else { UInt.max })
            }
            else if (negative) {
                value `=` -Int(num)
            }
            else {
                value `=` Int(num)
            }
        }

        return true
    }

    open fun scanInt(value: InOut<Int>): Boolean {
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if ((if ((_scanLocation >= _string.utf16.count)) { false } else { true }) && this._scanInt(value)) {
            return true
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanUnsignedLongLong_(
        value: InOut<ULong>,
        radix: UInt,
        max: ULong,
        gotDigits: Boolean)
        : Boolean
    {
        var gotDigits_: Boolean = gotDigits
        var num: ULong = 0u
        val numLimit: ULong = max / UInt64(radix)
        val digitLimit: ULong = max % UInt64(radix)
        var digitValue: ULong = 0u
        var overflow: Boolean = false
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count) {
            val digit: UShort = ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))

            when ((digit)) {
                "0".utf16.first!! -> digitValue = 0u
                "1".utf16.first!! -> digitValue = 1u
                "2".utf16.first!! -> digitValue = 2u
                "3".utf16.first!! -> digitValue = 3u
                "4".utf16.first!! -> digitValue = 4u
                "5".utf16.first!! -> digitValue = 5u
                "6".utf16.first!! -> digitValue = 6u
                "7".utf16.first!! -> digitValue = 7u
                "8".utf16.first!! -> digitValue = 8u
                "9".utf16.first!! -> digitValue = 9u
                "a".utf16.first!! -> digitValue = 0xau
                "b".utf16.first!! -> digitValue = 0xbu
                "c".utf16.first!! -> digitValue = 0xcu
                "d".utf16.first!! -> digitValue = 0xdu
                "e".utf16.first!! -> digitValue = 0xeu
                "f".utf16.first!! -> digitValue = 0xfu
                "A".utf16.first!! -> digitValue = 0xau
                "B".utf16.first!! -> digitValue = 0xbu
                "C".utf16.first!! -> digitValue = 0xcu
                "D".utf16.first!! -> digitValue = 0xdu
                "E".utf16.first!! -> digitValue = 0xeu
                "F".utf16.first!! -> digitValue = 0xfu
                else -> digitValue = UInt64(radix)
            }

            if (digitValue >= radix) {
                break
            }

            if (!overflow) {
                if ((num > numLimit) || ((num == numLimit) && (digitValue > digitLimit))) {
                    overflow = true
                }
                else {
                    num = num * UInt64(radix) + digitValue
                }
            }

            _scanLocation += 1

            gotDigits_ = true
        }

        if (!gotDigits_) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((value != null)) {
            if (overflow) {
                value `=` (9223372036854775807u * 2u + 1u)
            }
            else {
                value `=` num
            }
        }

        return true
    }

    open fun scanRadixUnsignedInt(value: InOut<UInt>): Boolean {
        var radix: UInt
        val tmp = InOut<ULong>()
        var gotDigits: Boolean = false
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        radix = 10u

        if ((_scanLocation < _string.utf16.count) && (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) == "0".utf16.first!!)) {
            radix = 8u

            _scanLocation += 1

            gotDigits = true

            if (_scanLocation < _string.utf16.count) {
                when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                    "x".utf16.first!!, "X".utf16.first!! -> {
                        _scanLocation += 1
                        radix = 16u
                        gotDigits = false
                    }
                    else -> {
                    }
                }
            }
        }

        if (this.scanUnsignedLongLong_(tmp, radix, 0xffffffffu, gotDigits)) {
            if (+tmp > 0xffffffffu) {
                value `=` 0xffffffffu
            }
            else {
                value `=` UInt(+tmp)
            }
            return true
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanRadixUnsignedLongLong(value: InOut<ULong>): Boolean {
        var radix: UInt
        var gotDigits: Boolean = false
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        radix = 10u

        if ((_scanLocation < _string.utf16.count) && (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) == "0".utf16.first!!)) {
            radix = 8u

            _scanLocation += 1

            gotDigits = true

            if (_scanLocation < _string.utf16.count) {
                when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                    "x".utf16.first!!, "X".utf16.first!! -> {
                        _scanLocation += 1
                        radix = 16u
                        gotDigits = false
                    }
                    else -> {
                    }
                }
            }
        }

        if (this.scanUnsignedLongLong_(value, radix, (9223372036854775807u * 2u + 1u), gotDigits)) {
            return true
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanHexInt(value: InOut<UInt>): Boolean {
        val saveScanLocation: Int = _scanLocation
        val tmp = InOut<ULong>()

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((_scanLocation < _string.utf16.count) && (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) == "0".utf16.first!!)) {
            _scanLocation += 1
            if (_scanLocation < _string.utf16.count) {
                when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                    "x".utf16.first!!, "X".utf16.first!! -> _scanLocation += 1
                    else -> _scanLocation -= 1
                }
            }
            else {
                _scanLocation -= 1
            }
        }

        if (this.scanUnsignedLongLong_(tmp, 16u, 0xffffffffu, false)) {
            value `=` UInt(+tmp)
            return true
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanLongLong(value: InOut<Long>): Boolean {
        var num: ULong = 0u
        val limit: ULong = (9223372036854775807u * 2u + 1u) / 10u
        var negative: Boolean = false
        var overflow: Boolean = false
        var got_digits: Boolean = false
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        if (_scanLocation < _string.utf16.count) {
            when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                "+".utf16.first!! -> _scanLocation += 1
                "-".utf16.first!! -> {
                    negative = true
                    _scanLocation += 1
                }
                else -> {
                }
            }
        }

        while (_scanLocation < _string.utf16.count) {
            val digit: UShort = ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))

            if ((digit < "0".utf16.first!!) || (digit > "9".utf16.first!!)) {
                break
            }

            if (!overflow) {
                if (num >= limit) {
                    overflow = true
                }
                else {
                    num = num * 10u + UInt64(digit - "0".utf16.first!!)
                }
            }

            _scanLocation += 1

            got_digits = true
        }

        if (!got_digits) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((value != null)) {
            if (negative) {
                if (overflow || (num > (UInt64_(-9223372036854775807 - 1)))) {
                    value `=` (-9223372036854775807 - 1)
                }
                else {
                    value `=` -Int64(num)
                }
            }
            else {
                if (overflow || (num > UInt64(9223372036854775807u))) {
                    value `=` 9223372036854775807
                }
                else {
                    value `=` Int64(num)
                }
            }
        }

        return true
    }

    open fun scanHexLongLong(value: InOut<ULong>): Boolean {
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((_scanLocation < _string.utf16.count) && (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) == "0".utf16.first!!)) {
            _scanLocation += 1
            if (_scanLocation < _string.utf16.count) {
                when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                    "x".utf16.first!!, "X".utf16.first!! -> _scanLocation += 1
                    else -> _scanLocation -= 1
                }
            }
            else {
                _scanLocation -= 1
            }
        }

        if (this.scanUnsignedLongLong_(value, 16u, (9223372036854775807u * 2u + 1u), false)) {
            return true
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanDecimal(value: Decimal): Boolean {
        throw NotImplementedError("Fatal error: ${"scanDecimal is not implemented"}");
        return false
    }

    open fun scanDouble(value: InOut<Double>): Boolean {
        var c: UShort = 0u
        var mantissa = mutableListOf<UShort>()
        var ptr: Int
        var d: Int
        var result: Double
        var e: Double
        var exponent: Int = 0
        var negativeMantissa: Boolean = false
        var negativeExponent: Boolean = false
        var shift: Int = 0
        var mantissaLength: Int
        var dotPos: Int = -1
        var hi: Int = 0
        var lo: Int = 0
        var mantissaDigit: Boolean = false
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            _scanLocation = saveScanLocation
            return false
        }

        if (_scanLocation < _string.utf16.count) {
            when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                "+".utf16.first!! -> _scanLocation += 1
                "-".utf16.first!! -> {
                    _scanLocation += 1
                    negativeMantissa = true
                }
                else -> {
                }
            }
        }

        if (_scanLocation >= _string.utf16.count) {
            _scanLocation = saveScanLocation
            return false
        }

        mantissaLength = 0

        while (_scanLocation < _string.utf16.count) {
            c = ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))
            if (c < "0".utf16.first!! || c > "9".utf16.first!!) {
                if (dotPos >= 0) {
                    break
                }
                if (_decimal == c || (_decimal > 127u && _decimal == ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])))) {
                    dotPos = mantissaLength
                }
                else {
                    break
                }
            }
            else {
                mantissaDigit = true
                if (0 == mantissaLength && "0".utf16.first!! == c) {
                    if (dotPos >= 0) {
                        shift += 1
                    }
                }
                else if (mantissaLength < 19) {
                    require(mantissa.size == mantissaLength)
                    mantissa.add(c)
                    mantissaLength += 1
                }
            }

            _scanLocation += 1
        }

        if (false == mantissaDigit) {
            _scanLocation = saveScanLocation
            return false
        }

        if (mantissaLength > 18) {
            mantissaLength = 18
        }

        if (dotPos < 0) {
            dotPos = mantissaLength
        }

        dotPos -= mantissaLength

        ptr = 0

        while (mantissaLength > 9) {
            c = mantissa[ptr]

            ptr += 1

            hi = hi * 10 + Int(c - "0".utf16.first!!)

            mantissaLength -= 1
        }

        while (mantissaLength > 0) {
            c = mantissa[ptr]

            ptr += 1

            lo = lo * 10 + Int(c - "0".utf16.first!!)

            mantissaLength -= 1
        }

        result = (1000000000.0 * hi.toDouble()) + lo.toDouble()

        var cond1: Boolean = _scanLocation < _string.utf16.count

        if (cond1) {
            c = _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]
        }

        if (cond1 && (c == "e".utf16.first!! || c == "E".utf16.first!!)) {
            val saveExpLoc: Int = _scanLocation
            _scanLocation += 1
            if (_scanLocation >= _string.utf16.count) {
                _scanLocation = saveExpLoc
            }
            else {
                when (((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))) {
                    "+".utf16.first!! -> _scanLocation += 1
                    "-".utf16.first!! -> {
                        _scanLocation += 1
                        negativeExponent = true
                    }
                    else -> {
                    }
                }

                var cond2: Boolean = _scanLocation >= _string.utf16.count

                if (!cond2) {
                    c = ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))
                }

                if (cond2 || c < "0".utf16.first!! || c > "9".utf16.first!!) {
                    _scanLocation = saveExpLoc
                }
                else {
                    exponent = Int(c - "0".utf16.first!!)
                    _scanLocation += 1
                    while (_scanLocation < _string.utf16.count) {
                        c = ((_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]))

                        if (!(c >= "0".utf16.first!! && c <= "9".utf16.first!!)) {
                            break
                        }

                        exponent = exponent * 10 + Int(c - "0".utf16.first!!)

                        _scanLocation += 1
                    }
                }
            }
        }

        if (true == negativeExponent) {
            exponent = dotPos - exponent
        }
        else {
            exponent = dotPos + exponent
        }

        exponent -= Int(shift)

        if (exponent < 0) {
            negativeExponent = true
            exponent = -exponent
        }
        else {
            negativeExponent = false
        }

        if (exponent > 511) {
            _scanLocation = saveScanLocation
            return false
        }

        e = 1.0
        d = 0

        while (exponent != 0) {
            if ((exponent and 1 != 0)) {
                e *= powersOf10[d]
            }
            exponent /= 2
            d += 1
        }

        if (true == negativeExponent) {
            result /= e
        }
        else {
            result *= e
        }

        if (null != value) {
            if (true == negativeMantissa) {
                value `=` -result
            }
            else {
                value `=` result
            }
        }

        return true
    }

    open fun scanFloat(value: InOut<Float>): Boolean {
        var num = InOut<Double>()

        if (value == null) {
            return this.scanDouble(InOut())
        }

        if (this.scanDouble(num)) {
            value `=` (+num).toFloat()
            return true
        }

        return false
    }

    open fun scanCharactersFromSet(aSet: NSCharacterSet, value: InOut<NSString>): Boolean {
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if ((if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            var start: Int

            start = _scanLocation

            if (_isUnicode) {
                while (_scanLocation < _string.utf16.count) {
                    if (aSet.characterIsMember(_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]) == false) {
                        break
                    }
                    _scanLocation += 1
                }
            }
            else {
                while (_scanLocation < _string.utf16.count) {
                    if (aSet.characterIsMember(_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]) == false) {
                        break
                    }
                    _scanLocation += 1
                }
            }

            if (_scanLocation != start) {
                if (value != null) {
                    var range: Range<StringUTF16ViewIndex> = _string.utf16.index(_string.utf16.startIndex, start) until _string.utf16.index(_string.utf16.startIndex, (_scanLocation))
                    value `=` _string.substring(range)
                }
                return true
            }
        }

        _scanLocation = saveScanLocation

        return false
    }

    open fun scanUpToCharactersFromSet(aSet: NSCharacterSet, value: InOut<NSString>): Boolean {
        val saveScanLocation: Int = _scanLocation
        var start: Int

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if (!(if ((_scanLocation >= _string.utf16.count)) { false } else { true })) {
            return false
        }

        start = _scanLocation

        if (_isUnicode) {
            while (_scanLocation < _string.utf16.count) {
                if (aSet.characterIsMember(_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]) == true) {
                    break
                }
                _scanLocation += 1
            }
        }
        else {
            while (_scanLocation < _string.utf16.count) {
                if (aSet.characterIsMember(_string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)]) == true) {
                    break
                }
                _scanLocation += 1
            }
        }

        if (_scanLocation == start) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((value != null)) {
            var range: Range<StringUTF16ViewIndex> = _string.utf16.index(_string.utf16.startIndex, start) until _string.utf16.index(_string.utf16.startIndex, (_scanLocation - start))
            value `=` _string.substring(range)
        }

        return true
    }

    open fun scanString(string: NSString, value: InOut<NSString>): Boolean {
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if ((if ((_scanLocation >= _string.utf16.count)) { false } else { true }) == false) {
            return false
        }

        var range: Range<StringUTF16ViewIndex> = _string.utf16.index(_string.utf16.startIndex, _scanLocation) until _string.utf16.index(_string.utf16.startIndex, Int(_scanLocation) + string.utf16.count)

        if (range.upperBound.utf16Offset(_string) > _string.utf16.count) {
            return false
        }

        range = _string.range(
            string,
            if (_caseSensitive) { NSString.CompareOptions() } else { StringCompareOption.caseInsensitive.toOptions() },
            range)!!

        if (range.isEmpty) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((value != null)) {
            value `=` _string.substring(range)
        }

        _scanLocation += Int(range.upperBound.utf16Offset(_string) - range.lowerBound.utf16Offset(_string))

        return true
    }

    open fun scanUpToString(string: NSString, value: InOut<NSString>): Boolean {
        val saveScanLocation: Int = _scanLocation

        while (_scanLocation < _string.utf16.count && _charactersToBeSkipped != null && _charactersToBeSkipped!!.characterIsMember(
            _string.utf16[_string.utf16.index(_string.utf16.startIndex, _scanLocation)])) {
            _scanLocation += 1
        }

        if ((if ((_scanLocation >= _string.utf16.count)) { false } else { true }) == false) {
            return false
        }

        var range: Range<StringUTF16ViewIndex> = _string.utf16.index(_string.utf16.startIndex, _scanLocation) until _string.utf16.index(_string.utf16.startIndex, _string.utf16.count)
        var found = _string.range(
            string,
            if (_caseSensitive) { NSString.CompareOptions() } else { StringCompareOption.caseInsensitive.toOptions() },
            range)

        if ((found?.isEmpty == false)) {
            range = range.lowerBound until _string.utf16.index(
                range.lowerBound,
                found!!.lowerBound.utf16Offset(_string.utf16) - Int(_scanLocation))
        }

        if (range.isEmpty) {
            _scanLocation = saveScanLocation
            return false
        }

        if ((value != null)) {
            value `=` _string.substring(range)
        }

        _scanLocation += Int(range.upperBound.utf16Offset(_string.utf16) - range.lowerBound.utf16Offset(_string.utf16))

        return true
    }

    open fun string(): NSString {
        return _string
    }

    open fun scanLocation(): Int {
        return _scanLocation
    }

    open fun setScanLocation(anIndex: Int) {
        if (_scanLocation <= _string.utf16.count) {
            _scanLocation = anIndex
        }
        else {
            throw NSError(
                "NSRangeException".toNSString(),
                0,
                mapOf(NSLocalizedDescriptionKey to "Attempt to set scan location beyond end of string".toNSString()))
        }
    }

    open fun caseSensitive(): Boolean {
        return _caseSensitive
    }

    open fun setCaseSensitive(flag: Boolean) {
        _caseSensitive = flag
    }

    open fun charactersToBeSkipped(): NSCharacterSet? {
        return _charactersToBeSkipped
    }

    open fun setCharactersToBeSkipped(aSet: NSCharacterSet?) {
        _charactersToBeSkipped = aSet?.copy() as? NSCharacterSet
    }

    open fun locale(): Map<NSString, Any>? {
        return _locale
    }

    open fun setLocale(localeDictionary: Map<NSString, Any>?) {
        _locale = (localeDictionary)
        if (_locale == null) {
            _decimal = ".".utf16.first!!
        }
        else {
            var pointString: NSString
            pointString = _locale!![NSDecimalSeparator] as NSString
            if (pointString.utf16.count > 0) {
                _decimal = pointString.utf16[pointString.utf16.index(pointString.utf16.startIndex, 0)]
            }
            else {
                _decimal = ".".utf16.first!!
            }
        }
    }

    open fun scanHexDouble(result: Double): Boolean {
        return false
    }

    open fun scanHexFloat(result: Float): Boolean {
        return false
    }

    open fun scanInteger(value: InOut<Int>): Boolean {
        return this.scanInt(value)
    }
}

internal enum class NSComparisonPredicateModifier(val rawValue: Int) {
    NS_DIRECT_PREDICATE_MODIFIER(rawValue = 0),
    NS_ALL_PREDICATE_MODIFIER(rawValue = 1),
    NS_ANY_PREDICATE_MODIFIER(rawValue = 2);

    companion object {
        operator fun invoke(rawValue: Int): NSComparisonPredicateModifier? = values().firstOrNull { it.rawValue == rawValue }
    }
}

internal enum class NSComparisonPredicateOptions(val rawValue: Int) {
    NS_CASE_INSENSITIVE_PREDICATE_OPTION(rawValue = 0x1),
    NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION(rawValue = 0x2);

    companion object {
        operator fun invoke(rawValue: Int): NSComparisonPredicateOptions? = values().firstOrNull { it.rawValue == rawValue }
    }
}

internal enum class NSPredicateOperatorType(val rawValue: Int) {
    NS_LESS_THAN_PREDICATE_OPERATOR_TYPE(rawValue = 0),
    NS_LESS_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE(rawValue = 1),
    NS_GREATER_THAN_PREDICATE_OPERATOR_TYPE(rawValue = 2),
    NS_GREATER_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE(rawValue = 3),
    NS_EQUAL_TO_PREDICATE_OPERATOR_TYPE(rawValue = 4),
    NS_NOT_EQUAL_TO_PREDICATE_OPERATOR_TYPE(rawValue = 5),
    NS_MATCHES_PREDICATE_OPERATOR_TYPE(rawValue = 6),
    NS_LIKE_PREDICATE_OPERATOR_TYPE(rawValue = 7),
    NS_BEGINS_WITH_PREDICATE_OPERATOR_TYPE(rawValue = 8),
    NS_ENDS_WITH_PREDICATE_OPERATOR_TYPE(rawValue = 9),
    NS_IN_PREDICATE_OPERATOR_TYPE(rawValue = 10),
    NS_CUSTOM_SELECTOR_PREDICATE_OPERATOR_TYPE(rawValue = 11),
    NS_CONTAINS_PREDICATE_OPERATOR_TYPE(rawValue = 99),
    NS_BETWEEN_PREDICATE_OPERATOR_TYPE(rawValue = 100);

    companion object {
        operator fun invoke(rawValue: Int): NSPredicateOperatorType? = values().firstOrNull { it.rawValue == rawValue }
    }
}

internal enum class NSCompoundPredicateType(val rawValue: Int) {
    NS_NOT_PREDICATE_TYPE(rawValue = 0),
    NS_AND_PREDICATE_TYPE(rawValue = 1),
    NS_OR_PREDICATE_TYPE(rawValue = 2);

    companion object {
        operator fun invoke(rawValue: Int): NSCompoundPredicateType? = values().firstOrNull { it.rawValue == rawValue }
    }
}

internal val evaluatedObjectExpression: NSExpression = GSEvaluatedObjectExpression()

abstract class NSPredicate: NSObject(), HasDescription {
    companion object {
        
        fun predicateWithFormat(format: NSString, vararg args: AnyObject) = predicateWithFormat(format, args.toList())
        fun predicateWithFormat(format: NSString, args: List<AnyObject>): NSPredicate {
            var s: GSPredicateScanner
            var p: NSPredicate

            s = GSPredicateScanner(format, args)
            p = s.parse()

            return p
        }

        fun predicateWithValue(value: Boolean): NSPredicate {
            if (value) {
                return GSTruePredicate()
            }
            else {
                return GSFalsePredicate()
            }
        }
    }

    abstract fun evaluateWithObject(`object`: AnyObject): Boolean

    override fun description(): NSString {
        return this.predicateFormat()
    }

    abstract fun predicateFormat(): NSString

    open fun predicateWithSubstitutionVariables(variables: Map<NSString, AnyObject>): NSPredicate {
        return (this.javaClass.getConstructor().newInstance()) as NSPredicate
    }

    open fun evaluateWithObject(`object`: AnyObject, variables: Map<NSString, AnyObject>): Boolean {
        return this.predicateWithSubstitutionVariables(variables).evaluateWithObject(`object` = `object`)
    }

}

internal open class GSTruePredicate: NSPredicate() {
    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        return true
    }

    override open fun predicateFormat(): NSString {
        return "TRUEPREDICATE".toNSString()
    }
}

internal open class GSFalsePredicate: NSPredicate() {
    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        return false
    }

    override open fun predicateFormat(): NSString {
        return "FALSEPREDICATE".toNSString()
    }
}

internal sealed abstract class NSCompoundPredicate(type: NSCompoundPredicateType, list: List<NSPredicate>):
    NSPredicate() {
    companion object {
        operator fun invoke(type: NSCompoundPredicateType, list: List<NSPredicate>): NSCompoundPredicate {
            return when(type) {
                NSCompoundPredicateType.NS_OR_PREDICATE_TYPE -> GSOrCompoundPredicate(type, list)
                NSCompoundPredicateType.NS_NOT_PREDICATE_TYPE -> GSNotCompoundPredicate(type, list)
                NSCompoundPredicateType.NS_AND_PREDICATE_TYPE -> GSAndCompoundPredicate(type, list)
            }
        }

        fun andPredicateWithSubpredicates(list: List<NSPredicate>): NSPredicate {
            return (GSAndCompoundPredicate(NSCompoundPredicateType.NS_AND_PREDICATE_TYPE, list))
        }

        fun notPredicateWithSubpredicate(predicate: NSPredicate): NSPredicate {
            var list: List<NSPredicate>
            list = listOf(predicate)
            return (GSNotCompoundPredicate(NSCompoundPredicateType.NS_NOT_PREDICATE_TYPE, list))
        }

        fun orPredicateWithSubpredicates(list: List<NSPredicate>): NSPredicate {
            return (GSOrCompoundPredicate(NSCompoundPredicateType.NS_OR_PREDICATE_TYPE, list))
        }
    }

    private var _type: NSCompoundPredicateType = type
    open var _subs: List<NSPredicate> = list.toMutableList()

    open fun compoundPredicateType(): NSCompoundPredicateType {
        return _type
    }

    open fun subpredicates(): List<NSPredicate> {
        return _subs
    }

    override open fun predicateWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSPredicate
    {
        val count: Int = _subs.size
        var esubs = mutableListOf<NSPredicate>()

        esubs.reserveCapacity(count)

        var i: Int
        var p: NSPredicate

        i = 0

        while (i < count) {
            esubs.add(_subs[i].predicateWithSubstitutionVariables(variables))
            i += 1
        }

        p = type(this).init(_type, esubs)

        return (p)
    }
}

internal open class GSAndCompoundPredicate(type: NSCompoundPredicateType, list: List<NSPredicate>): NSCompoundPredicate(type, list) {
    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        var e = _subs.makeIterator()
        while (true) {
            val p: NSPredicate? = e.next() as? NSPredicate
            if (p != null) {
                if (p.evaluateWithObject(`object` = `object`) == false) {
                    return false
                }
            }
            else {
                break
            }
        }
        return true
    }

    override open fun predicateFormat(): NSString {
        var fmt: NSString = "".toNSString()
        var e = _subs.makeIterator()
        var cnt: Int = 0

        while (true) {
            val sub: NSPredicate? = e.next() as? NSPredicate
            if (sub != null) {
                if (cnt == 0) {
                    fmt = sub.predicateFormat()
                }
                else {
                    if (cnt == 1 && (_subs[0] is NSCompoundPredicate) && (_subs[0] as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_OR_PREDICATE_TYPE) {
                        fmt = NSString("(%@)".toNSString(), fmt)
                    }
                    if ((sub is NSCompoundPredicate) && (sub as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_OR_PREDICATE_TYPE) {
                        fmt = NSString("%@ AND (%@)".toNSString(), fmt, sub.predicateFormat())
                    }
                    else {
                        fmt = NSString("%@ AND %@".toNSString(), fmt, sub.predicateFormat())
                    }
                }
                cnt += 1
            }
            else {
                break
            }
        }

        return fmt
    }
}

internal open class GSOrCompoundPredicate(type: NSCompoundPredicateType, list: List<NSPredicate>): NSCompoundPredicate(type, list) {
    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        var e = _subs.makeIterator()
        while (true) {
            val p: NSPredicate? = e.next() as? NSPredicate
            if (p != null) {
                if (p.evaluateWithObject(`object` = `object`) == true) {
                    return true
                }
            }
            else {
                break
            }
        }
        return false
    }

    override open fun predicateFormat(): NSString {
        var fmt: NSString = "".toNSString()
        var e = _subs.makeIterator()

        while (true) {
            val sub: NSPredicate? = e.next() as? NSPredicate
            if (sub != null) {
                if (!fmt.isEmpty()) {
                    fmt = NSString("%@ OR %@".toNSString(), fmt, sub.predicateFormat())
                }
                else {
                    fmt = sub.predicateFormat()
                }
            }
            else {
                break
            }
        }

        return fmt
    }
}

internal open class GSNotCompoundPredicate(type: NSCompoundPredicateType, list: List<NSPredicate>): NSCompoundPredicate(type, list) {

    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        val sub: NSPredicate = _subs[0]
        return !sub.evaluateWithObject(`object` = `object`)
    }

    override open fun predicateFormat(): NSString {
        val sub: NSPredicate = _subs[0]
        if ((sub is NSCompoundPredicate) && (sub as NSCompoundPredicate).compoundPredicateType() != NSCompoundPredicateType.NS_NOT_PREDICATE_TYPE) {
            return NSString("NOT(%@)".toNSString(), sub.predicateFormat())
        }
        return NSString("NOT %@".toNSString(), sub.predicateFormat())
    }
}

internal open class NSComparisonPredicate(
    left: NSExpression,
    right: NSExpression,
    modifier: NSComparisonPredicateModifier,
    type: NSPredicateOperatorType,
    opts: Int): NSPredicate() {
    companion object {
        fun predicateWithLeftExpression(
            left: NSExpression,
            right: NSExpression,
            modifier: NSComparisonPredicateModifier,
            type: NSPredicateOperatorType,
            opts: Int)
            : NSPredicate
        {
            return (NSComparisonPredicate(left, right, modifier, type, opts))
        }
    }

    private var _modifier: NSComparisonPredicateModifier
    private var _options: Int
    private var _type: NSPredicateOperatorType
    private var _left: NSExpression
    private var _right: NSExpression


    init
    {
        _left = (left)
        _right = (right)
        _modifier = modifier
        _type = type
        _options = opts
    }

    open fun comparisonPredicateModifier(): NSComparisonPredicateModifier {
        return _modifier
    }


    open fun leftExpression(): NSExpression {
        return _left
    }

    open fun options(): Int {
        return _options
    }

    open fun predicateOperatorType(): NSPredicateOperatorType {
        return _type
    }

    open fun rightExpression(): NSExpression {
        return _right
    }

    override open fun predicateFormat(): NSString {
        var modi: NSString = "".toNSString()
        var comp: NSString = "?comparison?".toNSString()
        var opt: NSString = "".toNSString()

        when ((_modifier)) {
            NSComparisonPredicateModifier.NS_DIRECT_PREDICATE_MODIFIER -> {
            }
            NSComparisonPredicateModifier.NS_ANY_PREDICATE_MODIFIER -> modi = "ANY ".toNSString()
            NSComparisonPredicateModifier.NS_ALL_PREDICATE_MODIFIER -> modi = "ALL".toNSString()
            else -> modi = "?modifier?".toNSString()
        }

        when ((_type)) {
            NSPredicateOperatorType.NS_LESS_THAN_PREDICATE_OPERATOR_TYPE -> comp = "<".toNSString()
            NSPredicateOperatorType.NS_LESS_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> comp = "<=".toNSString()
            NSPredicateOperatorType.NS_GREATER_THAN_PREDICATE_OPERATOR_TYPE -> comp = ">=".toNSString()
            NSPredicateOperatorType.NS_GREATER_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> comp = ">".toNSString()
            NSPredicateOperatorType.NS_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> comp = "==".toNSString()
            NSPredicateOperatorType.NS_NOT_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> comp = "!=".toNSString()
            NSPredicateOperatorType.NS_MATCHES_PREDICATE_OPERATOR_TYPE -> comp = "MATCHES".toNSString()
            NSPredicateOperatorType.NS_LIKE_PREDICATE_OPERATOR_TYPE -> comp = "LIKE".toNSString()
            NSPredicateOperatorType.NS_BEGINS_WITH_PREDICATE_OPERATOR_TYPE -> comp = "BEGINSWITH".toNSString()
            NSPredicateOperatorType.NS_ENDS_WITH_PREDICATE_OPERATOR_TYPE -> comp = "ENDSWITH".toNSString()
            NSPredicateOperatorType.NS_IN_PREDICATE_OPERATOR_TYPE -> comp = "IN".toNSString()
            NSPredicateOperatorType.NS_CUSTOM_SELECTOR_PREDICATE_OPERATOR_TYPE -> throw NotImplementedError("Fatal error: ${"Custom selector predicates are not supported"}")
            NSPredicateOperatorType.NS_CONTAINS_PREDICATE_OPERATOR_TYPE -> comp = "CONTAINS".toNSString()
            NSPredicateOperatorType.NS_BETWEEN_PREDICATE_OPERATOR_TYPE -> comp = "BETWEEN".toNSString()
        }

        when ((_options)) {
            NSComparisonPredicateOptions.NS_CASE_INSENSITIVE_PREDICATE_OPTION.rawValue -> opt = "[c]".toNSString()
            NSComparisonPredicateOptions.NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION.rawValue -> opt = "[d]".toNSString()
            NSComparisonPredicateOptions.NS_CASE_INSENSITIVE_PREDICATE_OPTION.rawValue or NSComparisonPredicateOptions.NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION.rawValue -> opt = "[cd]".toNSString()
            else -> {
            }
        }

        return NSString("%@%@ %@%@ %@".toNSString(), modi, _left, comp, opt, _right)
    }

    override open fun predicateWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSPredicate
    {
        var left: NSExpression
        var right: NSExpression

        left = _left._expressionWithSubstitutionVariables(variables)
        right = _right._expressionWithSubstitutionVariables(variables)

        if (_type == NSPredicateOperatorType.NS_CUSTOM_SELECTOR_PREDICATE_OPERATOR_TYPE) {
            throw NotImplementedError("Custom selector predicates are not supported")
        }
        else {
            return NSComparisonPredicate.predicateWithLeftExpression(
                left = left,
                right = right,
                modifier = _modifier,
                type = _type,
                opts = _options)
        }
    }

    open fun GSICUStringMatchesRegex(
        string: NSString,
        regex: NSString,
        opts: NSStringCompareOptions)
        : Boolean = try { // TODO: Avoid generation of 'return false' in the previous line
        GSICUStringMatchesRegexThrowing(string, regex, opts)
    } catch (e: com.github.tarcv.u4jregex.RegexParseException) {
        false
    } catch (e: IllegalStateException) {
        false
    } catch (e: IllegalArgumentException) {
        false
    }

    fun GSICUStringMatchesRegexThrowing(
        string: NSString,
        regex: NSString,
        opts: NSStringCompareOptions): Boolean
    {
        if (regex.length == 0) { // C version of regex API errors on empty strings
            throw IllegalArgumentException()
        }

        val result: Boolean = false;
        var flags = mutableListOf<com.github.tarcv.u4jregex.URegexpFlag>();

        flags += com.github.tarcv.u4jregex.URegexpFlag.UREGEX_DOTALL; // . is supposed to recognize newlines
        if (opts.contains(StringCompareOption.caseInsensitive)) {
            flags += com.github.tarcv.u4jregex.URegexpFlag.UREGEX_CASE_INSENSITIVE
        }

        val icuregex = com.github.tarcv.u4jregex.RegexPattern.compile(regex.toString(), flags);
        val matcher = icuregex.matcher()
        matcher.reset(string.toString())
        return matcher.matches()
    }

    open fun doubleValueFor(value: AnyObject): Double {
        if ((value is NSDate)) {
            return (value as NSDate).timeIntervalSinceReferenceDate
        }
        else {
            return if (value is Boolean) {
                value.toNSNumber().doubleValue
            } else if (value is Number) {
                value.toNSNumber().doubleValue
            } else {
                value.toString().toNSNumber().doubleValue
            }
        }
    }

    open fun _evaluateLeftValue(
        leftResult: AnyObject?,
        rightResult: AnyObject?,
        `object`: AnyObject)
        : Boolean
    {
        var compareOptions = NSString.CompareOptions(0u)
        var leftIsNil: Boolean
        var rightIsNil: Boolean

        leftIsNil = (leftResult == null)
        rightIsNil = (rightResult == null)

        if (leftIsNil || rightIsNil) {
            if (leftIsNil == rightIsNil) {
                if (NSPredicateOperatorType.NS_EQUAL_TO_PREDICATE_OPERATOR_TYPE == _type || NSPredicateOperatorType.NS_LESS_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE == _type || NSPredicateOperatorType.NS_GREATER_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE == _type) {
                    return true
                }
            }
            else if (NSPredicateOperatorType.NS_NOT_EQUAL_TO_PREDICATE_OPERATOR_TYPE == _type) {
                return true
            }
            return false
        }

        if (!((_options and NSComparisonPredicateOptions.NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION.rawValue) != 0)) {
            compareOptions.insert(StringCompareOption.literal)
        }

        if ((_options and NSComparisonPredicateOptions.NS_CASE_INSENSITIVE_PREDICATE_OPTION.rawValue != 0)) {
            compareOptions.insert(StringCompareOption.caseInsensitive)
        }

        return when ((_type)) {
            NSPredicateOperatorType.NS_LESS_THAN_PREDICATE_OPERATOR_TYPE -> {
                val ld: Double = this.doubleValueFor(value = leftResult!!)
                val rd: Double = this.doubleValueFor(value = rightResult!!)
                if ((ld < rd)) { true } else { false }
            }
            NSPredicateOperatorType.NS_LESS_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> {
                val ld: Double = this.doubleValueFor(value = leftResult!!)
                val rd: Double = this.doubleValueFor(value = rightResult!!)
                if ((ld <= rd)) { true } else { false }
            }
            NSPredicateOperatorType.NS_GREATER_THAN_PREDICATE_OPERATOR_TYPE -> {
                val ld: Double = this.doubleValueFor(value = leftResult!!)
                val rd: Double = this.doubleValueFor(value = rightResult!!)
                if ((ld > rd)) { true } else { false }
            }
            NSPredicateOperatorType.NS_GREATER_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> {
                val ld: Double = this.doubleValueFor(value = leftResult!!)
                val rd: Double = this.doubleValueFor(value = rightResult!!)
                if ((ld >= rd)) { true } else { false }
            }
            NSPredicateOperatorType.NS_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> {
                if (leftResult is Boolean && rightResult is Number) {
                    leftResult.toNSNumber().compareTo(rightResult.toNSNumber()) == 0
                } else if (leftResult is Number && rightResult is Boolean) {
                    leftResult.toNSNumber().compareTo(rightResult.toNSNumber()) == 0
                } else if (leftResult is Number && rightResult is Number) {
                    leftResult.toNSNumber().compareTo(rightResult.toNSNumber()) == 0
                } else {
                    leftResult!!.isEqual(rightResult)
                }
            }
            NSPredicateOperatorType.NS_NOT_EQUAL_TO_PREDICATE_OPERATOR_TYPE -> notIsEqual(leftResult!!, rightResult)
            NSPredicateOperatorType.NS_MATCHES_PREDICATE_OPERATOR_TYPE -> GSICUStringMatchesRegex(
    string = leftResult as NSString,
    regex = rightResult as NSString,
    opts = compareOptions)
            NSPredicateOperatorType.NS_LIKE_PREDICATE_OPERATOR_TYPE -> {
                var regex: NSString

                regex = (rightResult as NSString).replace("*".toNSString(), ".*".toNSString())
                regex = regex.replace("?".toNSString(), ".?".toNSString())
                regex = NSString("^%@\$".toNSString(), regex)

                GSICUStringMatchesRegex(string = leftResult as NSString, regex = regex, opts = compareOptions)
            }
            NSPredicateOperatorType.NS_BEGINS_WITH_PREDICATE_OPERATOR_TYPE -> {
                val ll: Int = (leftResult as NSString).length
                val rl: Int = (rightResult as NSString).length

                if (rl > ll) {
                    return false
                }

                val myStr: NSString = (leftResult as NSString)
                var range: Range<StringUTF16ViewIndex> = myStr.utf16.startIndex until myStr.utf16.index(myStr.utf16.startIndex, rl)

                (if (myStr.compare(rightResult!!, compareOptions, range) == ComparisonResult.orderedSame) { true } else { false })
            }
            NSPredicateOperatorType.NS_ENDS_WITH_PREDICATE_OPERATOR_TYPE -> {
                val ll: Int = (leftResult as NSString).length
                val rl: Int = (rightResult as NSString).length

                if (ll < rl) {
                    return false
                }

                val myStr: NSString = leftResult as NSString
                var range: Range<StringUTF16ViewIndex> = myStr.utf16.index(myStr.utf16.startIndex, ll - rl) until myStr.utf16.index(myStr.utf16.startIndex, rl)

                (if (myStr.compare(rightResult!! as NSString, compareOptions, range) == ComparisonResult.orderedSame) { true } else { false })
            }
            NSPredicateOperatorType.NS_IN_PREDICATE_OPERATOR_TYPE -> {
                if (!(rightResult is NSString)) {
                    val eArray: List<AnyObject>? = rightResult as? List<AnyObject>

                    if (eArray == null) {
                        throw NSError(
                            "NSInvalidArgumentException".toNSString(),
                            0,
                            mapOf(NSLocalizedDescriptionKey to "The right hand side for an IN operator must be a collection".toNSString()))
                    }

                    var e = eArray.makeIterator()

                    while (true) {
                        val value: AnyObject? = e.next() as? AnyObject
                        if (value != null) {
                            if (value.isEqual(leftResult!!)) {
                                return true
                            }
                        }
                        else {
                            break
                        }
                    }

                    return false
                }
                (if ((rightResult as NSString).range(leftResult as NSString, compareOptions)?.isEmpty == false) { true } else { false })
            }
            else -> false
        }
    }

    override open fun evaluateWithObject(`object`: AnyObject): Boolean {
        val leftValue: AnyObject? = _left.expressionValueWithObject(`object`, null)
        val rightValue: AnyObject? = _right.expressionValueWithObject(`object`, null)
        if (_modifier == NSComparisonPredicateModifier.NS_DIRECT_PREDICATE_MODIFIER) {
            return this._evaluateLeftValue(leftResult = leftValue, rightResult = rightValue, `object` = `object`)
        }
        else {
            val result: Boolean = (_modifier == NSComparisonPredicateModifier.NS_ALL_PREDICATE_MODIFIER)
            val leftVal: List<AnyObject>? = leftValue as? List<AnyObject>

            if (leftVal == null) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "The left hand side for an ALL or ANY operator must be a collection".toNSString()))
            }

            var e = leftVal.makeIterator()

            while (true) {
                val value: AnyObject? = e.next() as? AnyObject
                if (value != null) {
                    val eval: Boolean = this._evaluateLeftValue(leftResult = value, rightResult = rightValue, `object` = `object`)
                    if (eval != result) {
                        return eval
                    }
                }
                else {
                    break
                }
            }

            return result
        }
    }

}

internal abstract class NSExpression(): NSObject(), HasDescription {
    companion object {
        fun expressionForConstantValue(obj: Any?): NSExpression {
            require(obj !is InOut<*>)

            var e: GSConstantValueExpression

            e = GSConstantValueExpression(obj)

            return (e)
        }

        fun expressionForEvaluatedObject(): NSExpression {
            return evaluatedObjectExpression!!
        }

        fun expressionForFunction(name: NSString, args: List<AnyObject>): NSExpression {
            require(args.none { it is InOut<*> })

            var s: NSString

            s = NSString("_eval_%@:".toNSString(), name)
            val _selector = NSSelectorFromString(s)

            val _op = if ((name == "_add".toNSString())) {
                "+".toNSString()
            }
            else if ((name == "_sub".toNSString())) {
                "-".toNSString()
            }
            else if ((name == "_mul".toNSString())) {
                "*".toNSString()
            }
            else if ((name == "_div".toNSString())) {
                "/".toNSString()
            }
            else if ((name == "_pow".toNSString())) {
                "**".toNSString()
            }
            else {
                null
            }

            var e: GSFunctionExpression
            e = GSFunctionExpression(
                _selector = _selector,
                _op = _op,
                _function = (name),
                _argc = args.size,
                _args = (args)
            )

            if (!e.respondsToSelector(to = e._selector)) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Unknown function implementation".toNSString()))
            }

            return (e)
        }

        fun expressionForKeyPath(path: NSString): NSExpressionWithKeyPath {
            var e: GSKeyPathExpression

            if (!(path is NSString)) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Keypath is not NSString".toNSString()))
            }

            e = GSKeyPathExpression(_keyPath = (path))

            return (e)
        }

        fun expressionForKeyPathCompositionWithLeft(
            left: NSExpression,
            right: NSExpression)
            : NSExpression
        {
            var e: GSKeyPathCompositionExpression

            e = GSKeyPathCompositionExpression(
                _left = (left),
                _right = (right)
            )

            return (e)
        }

        fun expressionForVariable(string: NSString): NSExpression {
            var e: GSVariableExpression

            e = GSVariableExpression(_variable = (string))

            return (e)
        }
    }


    abstract override fun description(): NSString
    
    abstract fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?

    abstract fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
}
internal abstract class NSExpressionWithKeyPath(): NSExpression() {
    abstract fun keyPath(): NSString?
}


internal open class GSConstantValueExpression(val _obj: Any?): NSExpression() {

    open fun constantValue(): Any? {
        return _obj
    }

    override open fun description(): NSString {
        if ((_obj is NSString)) {
            var result = InOut<NSString>()
            GSPropertyListMake(_obj, null, false, true, 2, result)
            return +result!!
        }
        else if ((_obj is NSDate)) {
            return NSString("CAST(%15.6f, \"NSDate\")".toNSString(), (_obj as NSDate).timeIntervalSinceReferenceDate)
        }
        return (_obj as AnyObject).toNSString()
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        if ((_obj is List<*>) && _obj.firstOrNull() is NSExpression) {
            val count: Int = (_obj as List<AnyObject>).size
            var tmp = mutableListOf<AnyObject>()
            var index: Int = 0

            while (index < count) {
                val e: NSExpression = (_obj as List<NSExpression>)[index]

                index += 1

                val o: AnyObject = e.expressionValueWithObject(e, context)!!

                tmp.add(o)
            }

            return tmp as AnyObject
        }
        else {
            return _obj as AnyObject
        }
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        return this
    }
}

internal open class GSEvaluatedObjectExpression: NSExpressionWithKeyPath() {
    override open fun description(): NSString {
        return "SELF".toNSString()
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        return `object`
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        return this
    }

    override open fun keyPath(): NSString? {
        return "SELF".toNSString()
    }
}

internal open class GSVariableExpression(open var _variable: NSString): NSExpression() {

    override open fun description(): NSString {
        return NSString("\$%@".toNSString(), _variable)
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        return context!![_variable] as AnyObject
    }

    open fun variable(): NSString {
        return _variable
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        val result: AnyObject = variables[_variable] as AnyObject
        if (result != null) {
            return NSExpression.expressionForConstantValue(obj = result)
        }
        else {
            return this
        }
    }
}

internal open class GSKeyPathExpression(open var _keyPath: NSString): NSExpressionWithKeyPath() {

    override open fun description(): NSString {
        return _keyPath
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        return `object`.valueForKeyPath(_keyPath)
    }

    override open fun keyPath(): NSString {
        return _keyPath
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        return this
    }
}

internal open class GSKeyPathCompositionExpression(
    open var _left: NSExpression,
    open var _right: NSExpression    
): NSExpressionWithKeyPath() {

    override open fun description(): NSString {
        return NSString("%@.%@".toNSString(), _left, _right)
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        var object_: AnyObject = `object`
        object_ = _left.expressionValueWithObject(object_, context) as AnyObject
        return _right.expressionValueWithObject(object_, context)
    }

    override open fun keyPath(): NSString? {
        return null
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        var left: NSExpression
        var right: NSExpression

        left = _left._expressionWithSubstitutionVariables(variables)
        right = _right._expressionWithSubstitutionVariables(variables)

        return NSExpression.expressionForKeyPathCompositionWithLeft(left = left, right = right)
    }
}

internal open class GSFunctionExpression(
    open var _function: NSString,
    open var _args: List<AnyObject>,
    open var _argc: Int,
    open var _selector: Selector,
    open var _op: NSString?
): NSExpressionWithKeyPath() {

    open fun respondsToSelector(to: Selector): Boolean {
        return getMethodBySelector(to) != null
    }

    open fun arguments(): List<AnyObject> {
        return _args
    }

    override open fun description(): NSString {
        if (null != _op && 1 == _args.size) {
            val a0: GSFunctionExpression = _args[0] as GSFunctionExpression
            if (true == (a0 is GSFunctionExpression) && null != a0._op) {
                return NSString("%@(%@)".toNSString(), _op, a0)
            }
            return NSString("%@%@".toNSString(), _op, a0)
        }
        if (null != _op) {
            val a0 = _args[0]
            val a1 = _args[1]

            if (true == (a0 is GSFunctionExpression) && null != a0._op) {
                if (true == (a1 is GSFunctionExpression) && null != a1._op) {
                    return NSString("(%@) %@ (%@)".toNSString(), a0, _op, a1)
                }
                return NSString("(%@) %@ %@".toNSString(), a0, _op, a1)
            }

            if (true == (a1 is GSFunctionExpression) && null != a1._op) {
                return NSString("%@ %@ (%@)".toNSString(), a0, _op, a1)
            }

            return NSString("%@ %@ %@".toNSString(), a0, _op, a1)
        }
        return NSString("%@(%@)".toNSString(), this.function(), _args)
    }

    open fun function(): NSString {
        return _function
    }

    override open fun keyPath(): NSString? {
        return null
    }

    override open fun expressionValueWithObject(
        `object`: AnyObject,
        context: Map<NSString, AnyObject>?)
        : AnyObject?
    {
        var eargs = mutableListOf<AnyObject>()

        eargs.reserveCapacity(_argc)

        var i: Int

        i = 0

        while (i < _argc) {
            eargs.add((_args[i] as NSExpression).expressionValueWithObject(`object`, context) as AnyObject)
            i += 1
        }

        return this.performSelector(_selector, eargs, true) as AnyObject
    }

    open fun _enum(expressions: List<AnyObject>): IndexingIterator<AnyObject> {
        if (1 == _argc) {
            val o: AnyObject = expressions.lastOrNull() as AnyObject
            val s: List<AnyObject>? = o as? List<AnyObject>
            if (s != null) {
                return s.makeIterator()
            }
        }
        return expressions.makeIterator()
    }

    override open fun _expressionWithSubstitutionVariables(
        variables: Map<NSString, AnyObject>)
        : NSExpression
    {
        var args = mutableListOf<AnyObject>()

        args.reserveCapacity(_argc)

        var i: Int = 0

        while (i < _argc) {
            args.add((_args[i] as NSExpression)._expressionWithSubstitutionVariables(variables))
            i += 1
        }

        return NSExpression.expressionForFunction(_function, args)
    }

    open fun _eval__chs(expressions: List<NSNumber>): AnyObject {
        return NSNumber(-(expressions[0].int32Value))
    }

    open fun _eval__first(expressions: List<AnyObject>): AnyObject {
        return (expressions[0] as List<AnyObject>)[0] as AnyObject
    }

    open fun _eval__last(expressions: List<AnyObject>): AnyObject {
        return (expressions[0] as List<AnyObject>).lastOrNull() as AnyObject
    }

    open fun _eval__index(expressions: List<AnyObject>): AnyObject? {
        val left: AnyObject = expressions[0] as AnyObject
        val right: AnyObject = expressions[1] as AnyObject
        if ((left is Map<*, *>)) {
            return left[right]
        }
        else {
            return (left as List<AnyObject>)[Int((right.toNSNumber()).uint32Value)] as AnyObject
        }
    }

    open fun _eval__pow(expressions: List<NSNumber>): AnyObject {
        val left: NSNumber = expressions[0] as NSNumber
        val right: NSNumber = expressions[1] as NSNumber
        return NSNumber(pow(left.doubleValue, right.doubleValue))
    }

    open fun _eval__mul(expressions: List<NSNumber>): AnyObject {
        val left: NSNumber = expressions[0] as NSNumber
        val right: NSNumber = expressions[1] as NSNumber
        return NSNumber(left.doubleValue * right.doubleValue)
    }

    open fun _eval__div(expressions: List<NSNumber>): AnyObject {
        val left: NSNumber = expressions[0] as NSNumber
        val right: NSNumber = expressions[1] as NSNumber
        return NSNumber(left.doubleValue / right.doubleValue)
    }

    open fun _eval__add(expressions: List<NSNumber>): AnyObject {
        val left: NSNumber = expressions[0] as NSNumber
        val right: NSNumber = expressions[1] as NSNumber
        return NSNumber(left.doubleValue + right.doubleValue)
    }

    open fun _eval__sub(expressions: List<NSNumber>): AnyObject {
        val left: NSNumber = expressions[0] as NSNumber
        val right: NSNumber = expressions[1] as NSNumber
        return NSNumber(left.doubleValue - right.doubleValue)
    }

    open fun _eval_count(expressions: List<NSString>): AnyObject {
        precondition({ _argc == 1 })
        return NSNumber((expressions[0] as NSString).utf16.count)
    }

    open fun _eval_avg(expressions: List<NSNumber>): AnyObject {
        var e = this._enum(expressions)
        var sum: Double = 0.0
        var count: Int = 0

        while (true) {
            val o: NSNumber? = e.next()?.toNSNumber()
            if (o != null) {
                sum += o.doubleValue
                count += 1
            }
            else {
                break
            }
        }

        if (count == 0) {
            return NSNumber(0.0)
        }

        return NSNumber(sum / count.toDouble())
    }

    open fun _eval_max(expressions: List<NSNumber>): AnyObject {
        var e = this._enum(expressions)
        val o: NSNumber? = e.next()?.toNSNumber()
        var max: Double = o?.doubleValue ?: 0.0
        var cur: Double

        while (true) {
            val o: NSNumber? = e.next()?.toNSNumber()
            if (o != null) {
                cur = o.doubleValue
                if (max < cur) {
                    max = cur
                }
            }
            else {
                break
            }
        }

        return NSNumber(max)
    }

    open fun _eval_min(expressions: List<NSNumber>): AnyObject {
        var e = this._enum(expressions)
        val o: NSNumber? = e.next()?.toNSNumber()
        var min: Double = (o?.doubleValue ?: 0.0)
        var cur: Double

        while (true) {
            val o: NSNumber? = e.next()?.toNSNumber()
            if (o != null) {
                cur = o.doubleValue
                if (min > cur) {
                    min = cur
                }
            }
            else {
                break
            }
        }

        return NSNumber(min)
    }

    open fun _eval_sum(expressions: List<NSNumber>): AnyObject {
        var e = this._enum(expressions)
        var sum: Double = 0.0

        while (true) {
            val o: NSNumber? = e.next()?.toNSNumber()
            if (o != null) {
                sum += o.doubleValue
            }
            else {
                break
            }
        }

        return NSNumber(sum)
    }

    open fun _eval_CAST(expressions: List<AnyObject>): AnyObject? {
        val left = expressions[0].toNSNumber()
        val right: AnyObject = expressions[1]

        if ((right as? NSString == "NSDate".toNSString())) {
            return NSDate(left.doubleValue)
        }

        NSLog("Cast to unknown type %@".toNSString(), right)

        return null
    }
}

internal fun <Element: Any> List<Element>.filteredArrayUsingPredicate(predicate: NSPredicate): List<AnyObject> {
    var result = mutableListOf<Element>()

    result.reserveCapacity(this.size)

    var e = this.makeIterator()
    var `object`: AnyObject

    while (true) {
        val `object`: Element? = e.next()
        if (`object` != null) {
            if (predicate.evaluateWithObject(`object` = `object` as AnyObject) == true) {
                result.add(`object`)
            }
        }
        else {
            break
        }
    }

    return result.toMutableList() as List<AnyObject>
}

internal fun <T: Any> MutableList<T>.filterUsingPredicate(predicate: NSPredicate) {
    var count: Int = this.size
    while (true) {
        count -= 1
        if (count >= 0) {
            val `object`: AnyObject = this[count] as AnyObject
            if (predicate.evaluateWithObject(`object` = `object`) == false) {
                this.removeAt(count)
            }
        }
        else {
            break
        }
    }
}

internal fun NSSet.filteredSetUsingPredicate(predicate: NSPredicate): NSSet {
    var result: NSMutableSet
    var e = this.makeIterator()

    result = NSMutableSet(this.count)

    while (true) {
        val `object`: AnyObject? = e.next() as? AnyObject
        if (`object` != null) {
            if (predicate.evaluateWithObject(`object` = `object`) == true) {
                result.add(`object`)
            }
        }
    }

    return result.copy() as NSSet
}

internal fun NSMutableSet.filterUsingPredicate(predicate: NSPredicate) {
    var rejected: NSMutableSet
    var e = this.makeIterator()

    rejected = NSMutableSet(this.count)

    while (true) {
        val `object`: AnyObject? = e.next() as? AnyObject
        if (`object` != null) {
            if (predicate.evaluateWithObject(`object` = `object`) == false) {
                rejected.add(`object`)
            }
        }
        else {
            break
        }
    }

    this.minus(rejected as Set<Any>)
}

internal open class GSPredicateScanner(format: NSString, args: List<Any>): NSScanner(format) {
    private var _args: IndexingIterator<Any>

    init {
        _args = args.makeIterator()
    }

    open fun nextArg(): AnyObject {
        return _args.next() as AnyObject
    }

    open fun scanPredicateKeyword(key: NSString): Boolean {
        val loc: Int = this.scanLocation()
        var c: UShort

        this.setCaseSensitive(flag = false)


        if (!this.scanString(key, InOut())) {
            return false
        }

        if (this.isAtEnd()) {
            return true
        }

        c = this.string().utf16[this.string().utf16.index(this.string().utf16.startIndex, this.scanLocation())]

        if (!(NSCharacterSet.alphanumerics as NSCharacterSet).characterIsMember(c)) {
            return true
        }

        this.setScanLocation(anIndex = loc)

        return false
    }

    open fun parse(): NSPredicate {
        var r: NSPredicate? = null

        try {
            r = this.parsePredicate()
        }
        catch (localException: Exception) {
            NSLog("Parsing failed for %@ with %@".toNSString(), this.string(), localException)
            throw localException
        }

        if (!this.isAtEnd()) {
            throw NSError(
                "NSInvalidArgumentException".toNSString(),
                0,
                mapOf(NSLocalizedDescriptionKey to "Format string contains extra characters".toNSString()))
        }

        return r!!
    }

    open fun parsePredicate(): NSPredicate {
        return this.parseAnd()
    }

    open fun parseAnd(): NSPredicate {
        var l: NSPredicate = this.parseOr()
        while (this.scanPredicateKeyword(key = "AND".toNSString()) || this.scanPredicateKeyword(key = "&&".toNSString())) {
            val r: NSPredicate = this.parseOr()
            if ((r is NSCompoundPredicate) && (r as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_AND_PREDICATE_TYPE) {
                val right: NSCompoundPredicate = (r as NSCompoundPredicate)
                if ((l is NSCompoundPredicate) && (l as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_AND_PREDICATE_TYPE) {
                    var left: NSCompoundPredicate

                    left = (l as NSCompoundPredicate)

                    var subs = (left.subpredicates()).toMutableList()

                    subs.addAll(right.subpredicates())

                    l = NSCompoundPredicate.andPredicateWithSubpredicates(subs)
                }
                else {
                    var subs = right.subpredicates().toMutableList()
                    subs.add(0, l)
                    l = NSCompoundPredicate.andPredicateWithSubpredicates(subs)
                }
            }
            else if ((l is NSCompoundPredicate) && (l as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_AND_PREDICATE_TYPE) {
                var left: NSCompoundPredicate

                left = (l as NSCompoundPredicate)

                var subs = left.subpredicates().toMutableList()

                subs.add(r)

                l = NSCompoundPredicate.andPredicateWithSubpredicates(subs)
            }
            else {
                l = NSCompoundPredicate.andPredicateWithSubpredicates(listOf(l, r))
            }
        }
        return l
    }

    open fun parseNot(): NSPredicate {

        if (this.scanString("(".toNSString(), InOut())) {
            val r: NSPredicate = this.parsePredicate()
            if (!this.scanString(")".toNSString(), InOut())) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Missing ) in compound predicate".toNSString()))
            }
            return r
        }

        if (this.scanPredicateKeyword(key = "NOT".toNSString()) || this.scanPredicateKeyword(key = "!".toNSString())) {
            return NSCompoundPredicate.notPredicateWithSubpredicate(predicate = this.parseNot())
        }

        if (this.scanPredicateKeyword(key = "TRUEPREDICATE".toNSString())) {
            return NSPredicate.predicateWithValue(value = true)
        }

        if (this.scanPredicateKeyword(key = "FALSEPREDICATE".toNSString())) {
            return NSPredicate.predicateWithValue(value = false)
        }

        return this.parseComparison()
    }

    open fun parseOr(): NSPredicate {
        var l: NSPredicate = this.parseNot()
        while (this.scanPredicateKeyword(key = "OR".toNSString()) || this.scanPredicateKeyword(key = "||".toNSString())) {
            val r: NSPredicate = this.parseNot()
            if ((r is NSCompoundPredicate) && (r as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_OR_PREDICATE_TYPE) {
                val right: NSCompoundPredicate = (r as NSCompoundPredicate)
                if ((l is NSCompoundPredicate) && (l as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_OR_PREDICATE_TYPE) {
                    val left: NSCompoundPredicate = (l as NSCompoundPredicate)
                    var subs = left.subpredicates().toMutableList()

                    subs.addAll(right.subpredicates())

                    l = NSCompoundPredicate.orPredicateWithSubpredicates(subs)
                }
                else {
                    var subs = right.subpredicates().toMutableList()
                    subs.add(0, l)
                    l = NSCompoundPredicate.orPredicateWithSubpredicates(subs)
                }
            }
            else if ((l is NSCompoundPredicate) && (l as NSCompoundPredicate).compoundPredicateType() == NSCompoundPredicateType.NS_OR_PREDICATE_TYPE) {
                val left: NSCompoundPredicate = (l as NSCompoundPredicate)
                var subs = left.subpredicates().toMutableList()

                subs.add(r)

                l = NSCompoundPredicate.orPredicateWithSubpredicates(subs)
            }
            else {
                l = NSCompoundPredicate.orPredicateWithSubpredicates(listOf(l, r))
            }
        }
        return l
    }

    open fun parseComparison(): NSPredicate {
        var modifier: NSComparisonPredicateModifier = NSComparisonPredicateModifier.NS_DIRECT_PREDICATE_MODIFIER
        var type: NSPredicateOperatorType = NSPredicateOperatorType.NS_LESS_THAN_PREDICATE_OPERATOR_TYPE
        var opts: Int = 0
        var left: NSExpression
        var right: NSExpression
        var p: NSPredicate
        var negate: Boolean = false
        var swap: Boolean = false

        if (this.scanPredicateKeyword(key = "ANY".toNSString())) {
            modifier = NSComparisonPredicateModifier.NS_ANY_PREDICATE_MODIFIER
        }
        else if (this.scanPredicateKeyword(key = "ALL".toNSString())) {
            modifier = NSComparisonPredicateModifier.NS_ALL_PREDICATE_MODIFIER
        }
        else if (this.scanPredicateKeyword(key = "NONE".toNSString())) {
            modifier = NSComparisonPredicateModifier.NS_ANY_PREDICATE_MODIFIER
            negate = true
        }
        else if (this.scanPredicateKeyword(key = "SOME".toNSString())) {
            modifier = NSComparisonPredicateModifier.NS_ALL_PREDICATE_MODIFIER
            negate = true
        }

        left = this.parseExpression()


        if (this.scanString("!=".toNSString(), InOut()) || this.scanString("<>".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_NOT_EQUAL_TO_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanString("<=".toNSString(), InOut()) || this.scanString("=<".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_LESS_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanString(">=".toNSString(), InOut()) || this.scanString("=>".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_GREATER_THAN_OR_EQUAL_TO_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanString("<".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_LESS_THAN_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanString(">".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_GREATER_THAN_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanString("==".toNSString(), InOut()) || this.scanString("=".toNSString(), InOut())) {
            type = NSPredicateOperatorType.NS_EQUAL_TO_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "MATCHES".toNSString())) {
            type = NSPredicateOperatorType.NS_MATCHES_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "LIKE".toNSString())) {
            type = NSPredicateOperatorType.NS_LIKE_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "BEGINSWITH".toNSString())) {
            type = NSPredicateOperatorType.NS_BEGINS_WITH_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "ENDSWITH".toNSString())) {
            type = NSPredicateOperatorType.NS_ENDS_WITH_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "IN".toNSString())) {
            type = NSPredicateOperatorType.NS_IN_PREDICATE_OPERATOR_TYPE
        }
        else if (this.scanPredicateKeyword(key = "CONTAINS".toNSString())) {
            type = NSPredicateOperatorType.NS_IN_PREDICATE_OPERATOR_TYPE
            swap = true
        }
        else if (this.scanPredicateKeyword(key = "BETWEEN".toNSString())) {
            val exp: GSConstantValueExpression = this.parseSimpleExpression() as GSConstantValueExpression
            val a: List<AnyObject> = exp.constantValue() as List<AnyObject>
            var lower: NSNumber
            var upper: NSNumber
            var lexp: NSExpression
            var uexp: NSExpression
            var lp: NSPredicate
            var up: NSPredicate

            if (!(a is List<AnyObject>)) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "BETWEEN operator requires array argument".toNSString()))
            }

            lower = a[0].toNSNumber()
            upper = a[1].toNSNumber()
            lexp = NSExpression.expressionForConstantValue(obj = lower)
            uexp = NSExpression.expressionForConstantValue(obj = upper)
            lp = NSComparisonPredicate.predicateWithLeftExpression(
                left = left,
                right = lexp,
                modifier = modifier,
                type = NSPredicateOperatorType.NS_GREATER_THAN_PREDICATE_OPERATOR_TYPE,
                opts = opts)
            up = NSComparisonPredicate.predicateWithLeftExpression(
                left = left,
                right = uexp,
                modifier = modifier,
                type = NSPredicateOperatorType.NS_LESS_THAN_PREDICATE_OPERATOR_TYPE,
                opts = opts)

            return NSCompoundPredicate.andPredicateWithSubpredicates(listOf(lp, up))
        }
        else {
            throw NSError(
                "NSInvalidArgumentException".toNSString(),
                0,
                mapOf(NSLocalizedDescriptionKey to "Invalid comparison predicate".toNSString()))
        }

        if (this.scanString("[cd]".toNSString(), InOut())) {
            opts = NSComparisonPredicateOptions.NS_CASE_INSENSITIVE_PREDICATE_OPTION.rawValue or NSComparisonPredicateOptions.NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION.rawValue
        }
        else if (this.scanString("[c]".toNSString(), InOut())) {
            opts = NSComparisonPredicateOptions.NS_CASE_INSENSITIVE_PREDICATE_OPTION.rawValue
        }
        else if (this.scanString("[d]".toNSString(), InOut())) {
            opts = NSComparisonPredicateOptions.NS_DIACRITIC_INSENSITIVE_PREDICATE_OPTION.rawValue
        }

        right = this.parseExpression()

        if (swap == true) {
            val tmp: NSExpression = left
            left = right
            right = tmp
        }

        p = NSComparisonPredicate.predicateWithLeftExpression(
            left = left,
            right = right,
            modifier = modifier,
            type = type,
            opts = opts)

        return if (negate) { NSCompoundPredicate.notPredicateWithSubpredicate(predicate = p) } else { p }
    }

    open fun parseExpression(): NSExpression {
        return this.parseBinaryExpression()
    }

    open fun parseIdentifierExpression(): NSExpressionWithKeyPath {
        var _identifier: NSCharacterSet
        var ident = InOut<NSString>()

        this.scanString("#".toNSString(), InOut())

            _identifier = (NSCharacterSet("_\$abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".toNSString())) as NSCharacterSet

        if (!this.scanCharactersFromSet(_identifier, ident)) {
            throw NSError("NSInvalidArgumentException".toNSString(), 0, mapOf(NSLocalizedDescriptionKey to "Missing identifier".toNSString()))
        }

        return NSExpression.expressionForKeyPath(path = +ident)
    }

    open fun parseSimpleExpression(): NSExpression {
        var location: Int
        var dbl = InOut<Double>()

        if (this.scanDouble(dbl)) {
            return NSExpression.expressionForConstantValue(obj = NSNumber(+dbl))
        }


        if (this.scanString("-".toNSString(), InOut())) {
            return NSExpression.expressionForFunction("_chs".toNSString(), listOf(this.parseExpression()))
        }

        if (this.scanString("(".toNSString(), InOut())) {
            val arg: NSExpression = this.parseExpression()
            if (!this.scanString(")".toNSString(), InOut())) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Missing ) in expression".toNSString()))
            }
            return arg
        }

        if (this.scanString("{".toNSString(), InOut())) {
            var a = mutableListOf<NSExpression>()

            a.reserveCapacity(10)

            if (this.scanString("}".toNSString(), InOut())) {
                return NSExpression.expressionForConstantValue(obj = a)
            }

            a.add(this.parseExpression())

            while (this.scanString(",".toNSString(), InOut())) {
                a.add(this.parseExpression())
            }

            if (!this.scanString("}".toNSString(), InOut())) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Missing } in aggregate".toNSString()))
            }

            return NSExpression.expressionForConstantValue(obj = a)
        }

        if (this.scanPredicateKeyword(key = "NULL".toNSString()) || this.scanPredicateKeyword(key = "NIL".toNSString())) {
            return NSExpression.expressionForConstantValue(obj = null)
        }

        if (this.scanPredicateKeyword(key = "TRUE".toNSString()) || this.scanPredicateKeyword(key = "YES".toNSString())) {
            return NSExpression.expressionForConstantValue(obj = NSNumber(true))
        }

        if (this.scanPredicateKeyword(key = "FALSE".toNSString()) || this.scanPredicateKeyword(key = "NO".toNSString())) {
            return NSExpression.expressionForConstantValue(obj = NSNumber(false))
        }

        if (this.scanPredicateKeyword(key = "SELF".toNSString())) {
            return NSExpression.expressionForEvaluatedObject()
        }

        if (this.scanString("\$".toNSString(), InOut())) {
            val var0: NSExpressionWithKeyPath = this.parseIdentifierExpression()
            if ((var0.keyPath() == null)) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Invalid variable identifier".toNSString()))
            }
            return NSExpression.expressionForVariable(string = var0.keyPath()!!)
        }

        location = this.scanLocation()

        if (this.scanString("%".toNSString(), InOut())) {
            if (this.isAtEnd() == false) {
                var c: UShort = this.string().utf16[this.string().utf16.index(this.string().utf16.startIndex, this.scanLocation())]
                when ((c)) {
                    "%".utf16.first!! -> location = this.scanLocation()
                    "K".utf16.first!! -> {
                        this.setScanLocation(anIndex = this.scanLocation() + 1)
                        return NSExpression.expressionForKeyPath(path = this.nextArg() as NSString)
                    }
                    "@".utf16.first!!, "c".utf16.first!!, "C".utf16.first!!, "d".utf16.first!!, "D".utf16.first!!, "i".utf16.first!!, "o".utf16.first!!, "O".utf16.first!!, "u".utf16.first!!, "U".utf16.first!!, "x".utf16.first!!, "X".utf16.first!!, "e".utf16.first!!, "E".utf16.first!!, "f".utf16.first!!, "g".utf16.first!!, "G".utf16.first!! -> {
                        this.setScanLocation(anIndex = this.scanLocation() + 1)
                        return NSExpression.expressionForConstantValue(obj = this.nextArg())
                    }
                    "h".utf16.first!! -> {
                        (this.scanString("h".toNSString(), InOut()))
                        if (this.isAtEnd() == false) {
                            c = this.string().utf16[this.string().utf16.index(this.string().utf16.startIndex, this.scanLocation())]
                            if (c == "i".utf16.first!! || c == "u".utf16.first!!) {
                                this.setScanLocation(anIndex = this.scanLocation() + 1)
                                return NSExpression.expressionForConstantValue(obj = this.nextArg())
                            }
                        }
                    }
                    "q".utf16.first!! -> {
                        (this.scanString("q".toNSString(), InOut()))
                        if (this.isAtEnd() == false) {
                            c = this.string().utf16[this.string().utf16.index(this.string().utf16.startIndex, this.scanLocation())]
                            if (c == "i".utf16.first!! || c == "u".utf16.first!! || c == "x".utf16.first!! || c == "X".utf16.first!!) {
                                this.setScanLocation(anIndex = this.scanLocation() + 1)
                                return NSExpression.expressionForConstantValue(obj = this.nextArg())
                            }
                        }
                    }
                    else -> {
                    }
                }
            }
            this.setScanLocation(anIndex = location)
        }

        if (this.scanString("\"".toNSString(), InOut())) {
            val skip: NSCharacterSet? = this.charactersToBeSkipped()
            var str = InOut<NSString>()

            this.setCharactersToBeSkipped(aSet = NSCharacterSet())

            if (!this.scanUpToString("\"".toNSString(), str)) {
                this.setCharactersToBeSkipped(aSet = skip)
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Invalid double quoted literal".toNSString()))
            }

            this.setCharactersToBeSkipped(aSet = skip)

            if (false == this.scanString("\"".toNSString(), InOut())) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Unterminated double quoted literal".toNSString()))
            }

            return NSExpression.expressionForConstantValue(obj = +str)
        }

        if (this.scanString("'".toNSString(), InOut())) {
            val skip: NSCharacterSet? = this.charactersToBeSkipped()
            var str = InOut<NSString>()

            this.setCharactersToBeSkipped(aSet = null)

            if (this.scanUpToString("'".toNSString(), str) == false) {
                this.setCharactersToBeSkipped(aSet = skip)
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Invalid single quoted literal".toNSString()))
            }

            this.setCharactersToBeSkipped(aSet = skip)

            if (false == this.scanString("'".toNSString(), InOut())) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Unterminated single quoted literal".toNSString()))
            }

            return NSExpression.expressionForConstantValue(obj = +str)
        }

        if (this.scanString("@".toNSString(), InOut())) {
            val e: NSExpressionWithKeyPath = this.parseIdentifierExpression()
            if ((e.keyPath() == null)) {
                throw NSError(
                    "NSInvalidArgumentException".toNSString(),
                    0,
                    mapOf(NSLocalizedDescriptionKey to "Invalid keypath identifier".toNSString()))
            }
            return NSExpression.expressionForKeyPath(path = NSString("@%@".toNSString(), e.keyPath()!!))
        }

        return this.parseIdentifierExpression()
    }

    open fun parseFunctionalExpression(): NSExpression {
        var left: NSExpression = this.parseSimpleExpression()
        while (true) {
            if (this.scanString("(".toNSString(), InOut())) {
                var args = mutableListOf<NSExpression>()

                args.reserveCapacity(5)

                if (left !is NSExpressionWithKeyPath || (left.keyPath() == null)) {
                    throw NSError(
                        "NSInvalidArgumentException".toNSString(),
                        0,
                        mapOf(NSLocalizedDescriptionKey to "Invalid function identifier".toNSString()))
                }

                if (!this.scanString(")".toNSString(), InOut())) {
                    args.add(this.parseExpression())
                    while (this.scanString(",".toNSString(), InOut())) {
                        args.add(this.parseExpression())
                    }
                    if (!this.scanString(")".toNSString(), InOut())) {
                        throw NSError(
                            "NSInvalidArgumentException".toNSString(),
                            0,
                            mapOf(NSLocalizedDescriptionKey to "Missing ) in function arguments".toNSString()))
                    }
                }

                left = NSExpression.expressionForFunction(left.keyPath()!!, args)
            }
            else if (this.scanString("[".toNSString(), InOut())) {
                if (this.scanPredicateKeyword(key = "FIRST".toNSString())) {
                    left = NSExpression.expressionForFunction("_first".toNSString(), listOf(this.parseExpression()))
                }
                else if (this.scanPredicateKeyword(key = "LAST".toNSString())) {
                    left = NSExpression.expressionForFunction("_last".toNSString(), listOf(this.parseExpression()))
                }
                else if (this.scanPredicateKeyword(key = "SIZE".toNSString())) {
                    left = NSExpression.expressionForFunction("count".toNSString(), listOf(this.parseExpression()))
                }
                else {
                    left = NSExpression.expressionForFunction("_index".toNSString(), listOf(left, this.parseExpression()))
                }
                if (!this.scanString("]".toNSString(), InOut())) {
                    throw NSError(
                        "NSInvalidArgumentException".toNSString(),
                        0,
                        mapOf(NSLocalizedDescriptionKey to "Missing ] in index argument".toNSString()))
                }
            }
            else if (this.scanString(".".toNSString(), InOut())) {
                var right: NSExpression
                right = this.parseExpression()
                if (evaluatedObjectExpression != left) {
                    if (((left as? NSExpressionWithKeyPath)?.keyPath() != null) && ((right as? NSExpressionWithKeyPath)?.keyPath() != null)) {
                        left = NSExpression.expressionForKeyPath(path = NSString("%@.%@".toNSString(), left.keyPath()!!, right.keyPath()!!))
                    }
                    else {
                        left = NSExpression.expressionForKeyPathCompositionWithLeft(left = left, right = right)
                    }
                }
                else {
                    left = NSExpression.expressionForKeyPath(path = (right as NSExpressionWithKeyPath).keyPath()!!)
                }
            }
            else {
                return left
            }
        }
    }

    open fun parsePowerExpression(): NSExpression {
        var left: NSExpression = this.parseFunctionalExpression()
        while (true) {
            var right: NSExpression
            if (this.scanString("**".toNSString(), InOut())) {
                right = this.parseFunctionalExpression()
                left = NSExpression.expressionForFunction("_pow".toNSString(), listOf(left, right))
            }
            else {
                return left
            }
        }
    }

    open fun parseMultiplicationExpression(): NSExpression {
        var left: NSExpression = this.parsePowerExpression()
        while (true) {
            var right: NSExpression
            if (this.scanString("*".toNSString(), InOut())) {
                right = this.parsePowerExpression()
                left = NSExpression.expressionForFunction("_mul".toNSString(), listOf(left, right))
            }
            else if (this.scanString("/".toNSString(), InOut())) {
                right = this.parsePowerExpression()
                left = NSExpression.expressionForFunction("_div".toNSString(), listOf(left, right))
            }
            else {
                return left
            }
        }
    }

    open fun parseAdditionExpression(): NSExpression {
        var left: NSExpression = this.parseMultiplicationExpression()
        while (true) {
            var right: NSExpression
            if (this.scanString("+".toNSString(), InOut())) {
                right = this.parseMultiplicationExpression()
                left = NSExpression.expressionForFunction("_add".toNSString(), listOf(left, right))
            }
            else if (this.scanString("-".toNSString(), InOut())) {
                right = this.parseMultiplicationExpression()
                left = NSExpression.expressionForFunction("_sub".toNSString(), listOf(left, right))
            }
            else {
                return left
            }
        }
    }

    open fun parseBinaryExpression(): NSExpression {
        val left: NSExpression = this.parseAdditionExpression()
        while (true) {
            var right: NSExpression
            if (this.scanString(":=".toNSString(), InOut())) {
                right = this.parseAdditionExpression()
            }
            else {
                return left
            }
        }
    }
}

